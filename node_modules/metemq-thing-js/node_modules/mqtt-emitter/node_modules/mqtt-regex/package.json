{
  "name": "mqtt-regex",
  "version": "1.0.5",
  "description": "Converts an MQTT topic with parameters into a regular expression.",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "browserify index.js --standalone mqtt_regex > build/build.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/RangerMauve/mqtt-regex.git"
  },
  "keywords": [
    "mqtt",
    "regex",
    "router"
  ],
  "author": {
    "name": "RangerMauve"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/RangerMauve/mqtt-regex/issues"
  },
  "homepage": "https://github.com/RangerMauve/mqtt-regex",
  "devDependencies": {
    "browserify": "^5.12.1"
  },
  "dependencies": {
    "escape-string-regexp": "^1.0.2"
  },
  "readme": "mqtt-regex\r\n==========\r\n\r\nConverts an MQTT topic with parameters into a regular expression.\r\n\r\n## Example\r\n\r\n``` javascript\r\nvar mqtt_regex = require(\"mqtt-regex\");\r\n\r\nvar pattern = \"chat/+id/+user/#path\";\r\n\r\nvar room_message_info = mqtt_regex(pattern).exec;\r\n\r\nvar topic = \"chat/lobby/bob/text\";\r\n\r\nvar message_content = \"Hello, World!\";\r\n\r\nvar params = room_message_info(topic);\r\n\r\nif(params && (params.path.indexOf(\"text\") !== -1)) {\r\n\tchat.getRoom(params.id).sendFrom(params.user, message_content)\r\n}\r\n```\r\n\r\n## Installing\r\n\r\nWith npm:\r\n\r\n\t$ npm install --save mqtt-regex\r\n\r\nTo use it in the browser, either compile a package with `node run build` or\r\nuse [Browserify](http://browserify.org).\r\n\r\n## API\r\nThe API is super simple and should be easy to integrate with any project\r\n\r\n### mqtt_regex(topic_pattern)\r\nTakes an MQTT topic pattern, and generates a RegExp object along with a function for parsing params from the result. The results also have an `exec` function that does both.\r\nThe return looks like\r\n``` javascript\r\n{\r\n\tregex: \"RegExp object for matching\"\r\n\tgetParams: function(results){\r\n\t\t// Processes results from RegExp.prototype.exec\r\n\t\t// Returns an object containing the values for each param\r\n\t},\r\n\texec: function(topic){\r\n\t\t// Performs regex.exec on topic\r\n\t\t// If there was a match, parses parameters and returns result\r\n\t},\r\n\ttopic: \"Regular MQTT topic with the pattern stuff stripped out\"\r\n}\r\n```\r\n\r\n## How params work\r\n\r\nMQTT defines two types of \"wildcards\", one for matching a single section of the path (`+`), and one for zero or more sections of the path (`#`).\r\nNote that the `#` wildcard can only be used if it's at the end of the topic.\r\nThis library was inspired by the syntax in the routers for Express and Sinatra, and an attempt was made to have this just as simple to use.\r\n\r\n### Examples of topic patterns:\r\n\r\n#### user/+id/#path\r\nThis would match paths that start with `user/`, and then extract the next section as the user `id`.\r\nThen it would get all subsequent paths and turn them into an array for the `path` param.\r\nHere is some input/output that you can expect:\r\n\r\n\tuser/bob/status/mood: {id: \"bob\", path:[\"status\",\"mood\"]\r\n\tuser/bob: {id:\"bob\", path: []}\r\n\tuser/bob/ishungry: {id: \"bob\", path: [\"ishungry\"]\r\n\r\n#### device/+/+/component/+type/#path\r\nNot all wildcards need to be associated with a parameter, and it could be useful to just use plain MQTT topics.\r\nIn this example you might only care about the status of some part of a device, and are willing to ignore a part of the path.\r\nHere are some examples of what this might be used with:\r\n\r\n\tdevice/deviceversion/deviceidhere/component/infrared/status/active: {type:\"infrared\",path: [\"status\",\"active\"]}\r\n",
  "readmeFilename": "README.md",
  "_id": "mqtt-regex@1.0.5",
  "_shasum": "2da2d9c7ba4574b5340db661ceb6e103e5de454d",
  "_resolved": "https://registry.npmjs.org/mqtt-regex/-/mqtt-regex-1.0.5.tgz",
  "_from": "mqtt-regex@>=1.0.4 <2.0.0"
}
