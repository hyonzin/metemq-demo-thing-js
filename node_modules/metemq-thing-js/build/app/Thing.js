"use strict";
var mqtt = require('mqtt');
var _ = require('underscore');
var MqttEmitter = require('mqtt-emitter');
var utils_1 = require('./utils');
var Subscription_1 = require('./Subscription');
var thingOptions_1 = require('./thingOptions');
var binding_1 = require('./binding');
/**
 * Thing class
 */
var Thing = (function () {
    /**
     * Constructor
     */
    function Thing(thingId, options) {
        this.mqttEmitter = new MqttEmitter();
        if (typeof thingId !== 'string')
            throw new Error('Type of thingId should be string');
        options = _.extend(thingOptions_1.DEFAULT_THING_OPTIONS, options);
        this.initialize(thingId, options);
    }
    /**
     * Function for initialize thing's ID, Username, and MQTT Client
     */
    Thing.prototype.initialize = function (thingId, options) {
        var _this = this;
        this.id = thingId;
        this.username = options.username;
        this.mqttClient = mqtt.connect(options.url, {
            clientId: thingId,
            username: options.username,
            password: options.password
        });
        this.setDefaultListener();
        this.mqttClient.on('message', function (topic, messageBuf) {
            var payload = messageBuf.toString();
            _this.mqttEmitter.emit(topic, payload);
        });
    };
    /**
     * Function for handle default topics
     */
    Thing.prototype.setDefaultListener = function () {
        this.mqttClient.subscribe(this.id + "/$suback/#");
        this.mqttClient.subscribe(this.id + "/$callack/#");
    };
    /**
     * Function same with 'this.mqttClient.on'
     *
     * @return Thing
     */
    Thing.prototype.on = function (event, listener) {
        this.mqttClient.on(event, listener);
        return this;
    };
    /**
     * Function for MQTT subscription a publication
     *
     * @param {string} publishName - what this thing is subscribing
     * @param {...object} [optionsOrCallback] - options for subscribing or callback
     * @param {function} [callback] - callback
     * @return Thing.Subscription
     * @example subscribeTopic('mPublishName');
     * @example subscribeTopic('mPublishName', { event: 'added' });
     */
    Thing.prototype.subscribe = function (name) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (typeof name !== 'string')
            throw new Error('publish name should be string!');
        var callback;
        if (args && args.length > 0 && typeof args[args.length - 1] == 'function')
            callback = args.pop();
        // MQTT subscribe, and then DDMQ subscribe
        this.twoPhaseSubscribe(name, args, callback);
        // after reconnection, it needs to request supscription again
        this.on('reconnect', function () { return _this.twoPhaseSubscribe(name, args, callback); });
        return new Subscription_1.Subscription(this, name);
    };
    Thing.prototype.twoPhaseSubscribe = function (name, params, callback) {
        var _this = this;
        this.mqttSubscribe(name, function () { return _this.ddmqSubscribe(name, params, callback); });
    };
    Thing.prototype.mqttSubscribe = function (name, callback) {
        this.mqttClient.subscribe(this.id + "/" + name + "/#", function (err, granted) {
            // fired on MQTT suback
            // ex) args : [{ topic: 'myThing01/$inbox/#', qos: 0 }]
            // (args[0].qos is 128 on error)
            if (err || granted[0].qos > 2)
                throw new Error("Subscription \"" + name + "\" fail: MQTT subscription fail");
            if (typeof callback === 'function')
                callback();
        });
    };
    /**
     * Function for DDMQ Subscription
     *
     * @param {string} publishName - what this thing is subscribing
     * @param {object} [options] - options for subscribing
     * @param {function} [callback] - callback
     * @return void
     * @example DDMQSubscribeTopic('mPublishName');
     * @example DDMQSubscribeTopic('mPublishName', { event: 'added' });
     */
    Thing.prototype.ddmqSubscribe = function (name, params, callback) {
        this.mqttClient.publish(this.id + "/$sub/" + name, utils_1.mkString(params));
        this.mqttEmitter.once(this.id + "/$suback/" + name, function (payload) {
            var code = Number(payload);
            if (code)
                throw new Error('Subscription refused');
            if (typeof callback === 'function')
                callback();
        });
    };
    /**
     * Function to MQTT unsubscribe
     *
     * @param {string} publishName - what this thing is unsubscribing
     * @param {function} [callback] - callback
     * @return void
     */
    Thing.prototype.unsubscribe = function (name, callback) {
        if (typeof name !== 'string')
            throw new Error('publish name should be string!');
        var topic = this.id + "/" + name + "/#";
        this.mqttClient.unsubscribe(topic, callback);
    };
    /**
     * Method Call
     * (MeteMQ Remote Procedure Call)
     *
     * @param {string} method
     * @param {...object} [optionsOrCallback] - options for method or callback
     * @return
     */
    Thing.prototype.call = function (method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var msgId = utils_1.genMsgId(8);
        var callback;
        if (args && args.length > 0 && typeof args[args.length - 1] == 'function')
            callback = args.pop();
        this.mqttClient.publish(this.id + "/$call/" + method + "/" + msgId, utils_1.mkString(args));
        this.mqttEmitter.once(this.id + "/$callack/" + msgId + "/+code", function (payload, params) {
            var code = Number(params.code);
            if (code)
                throw new Error("Method " + method + " call refused: error code [" + params.code[0] + "]");
            if (typeof callback === 'function')
                callback(utils_1.parseValue(payload));
        });
    };
    /**
     * 4-Way data binding
     *
     * @param {string} field
     * @param {object} value
     * @param {function} [callback]
     * @return Thing
     */
    Thing.prototype.bind = function (field, updateFunction) {
        if (!updateFunction)
            updateFunction = function (value) { return value; };
        return new binding_1.Binding(field, updateFunction, this);
    };
    return Thing;
}());
exports.Thing = Thing;
//# sourceMappingURL=Thing.js.map